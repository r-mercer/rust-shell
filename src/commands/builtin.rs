use crate::commands::{command_type::LineCommand, ext};
use pathsearch::find_executable_in_path;
use std::io;

pub fn exec_builtin(command: LineCommand) -> Result<Option<String>, io::Error> {
    let matched_command = command.execute.as_str();
    match matched_command {
        // "admin" => (),
        // "alias" => (),
        // "ar" => (),
        // "asa" => (),
        // "at" => (),
        // "awk" => (),
        // "basename" => (),
        // "batch" => (),
        // "bc" => (),
        // "bg" => (),
        // "cal" => (),
        "cd" => {
            ext::cd(command.args)?;
            Ok(None)
        }
        "cat" => Ok(Some(ext::cat(command.args)?)),
        // "cat" => return Ok(ext::cat(par)),
        // "cc" => (),
        // "cflow" => (),
        // "chgrp" => (),
        // "chmod" => (),
        // "chown" => (),
        // "cksum" => (),
        // "cmp" => (),
        // "comm" => (),
        // "command" => (),
        // "compress" => (),
        // "cp" => (),
        // "cron" => (),
        // "csplit" => (),
        // "ctags" => (),
        // "cut" => (),
        // "cxref" => (),
        // "date" => (),
        // "dd" => (),
        // "delta" => (),
        // "df" => (),
        // "diff" => (),
        // "dirname" => (),
        // "du" => (),
        "echo" => Ok(Some(ext::echo(command.args)?)),
        // "ed" => (),
        // "env" => (),
        // "ex" => (),
        // "expand" => (),
        // "expr" => (),
        // "false" => (),
        // "fc" => (),
        // "fg" => (),
        // "file" => (),
        // "find" => (),
        // "fold" => (),
        // "fuser" => (),
        // "gencat" => (),
        // "get" => (),
        // "getconf" => (),
        // "getopts" => (),
        // "gettext" => (),
        // "grep" => (),
        // "hash" => (),
        // "head" => (),
        // "iconv" => (),
        // "id" => (),
        // "ipcrm" => (),
        // "ipcs" => (),
        // "jobs" => (),
        // "join" => (),
        // "kill" => (),
        // "lex" => (),
        // "link" => (),
        // "ln" => (),
        // "locale" => (),
        // "localedef" => (),
        // "logger" => (),
        // "logname" => (),
        // "lp" => (),
        "ls" => Ok(Some(ext::print_ls(command.args)?)),
        // "m4" => (),
        // "mailx" => (),
        // "make" => (),
        // "man" => (),
        // "mesg" => (),
        // "mkdir" => (),
        // "mkfifo" => (),
        // "more" => (),
        // "msgfmt" => (),
        // "mv" => (),
        // "newgrp" => (),
        // "ngettext" => (),
        // "nice" => (),
        // "nl" => (),
        // "nm" => (),
        // "nohup" => (),
        // "od" => (),
        // "paste" => (),
        // "patch" => (),
        // "pathchk" => (),
        // "pax" => (),
        // "pr" => (),
        // "printf" => (),
        // "prs" => (),
        // "ps" => (),
        "pwd" => Ok(Some(ext::print_wd()?)),
        // "read" => (),
        // "readlink" => (),
        // "realpath" => (),
        // "renice" => (),
        // "rm" => (),
        // "rmdel" => (),
        // "rmdir" => (),
        // "sact" => (),
        // "sccs" => (),
        // "sed" => (),
        // "sh" => (),
        // "sleep" => (),
        // "sort" => (),
        // "split" => (),
        // "strings" => (),
        // "strip" => (),
        // "stty" => (),
        // "tabs" => (),
        // "tail" => (),
        // "talk" => (),
        // "tee" => (),
        // "test" => (),
        // "time" => (),
        // "timeout" => (),
        // "touch" => (),
        // "tput" => (),
        // "tr" => (),
        // "true" => (),
        // "tsort" => (),
        // "tty" => (),
        "type" => {
            if BUILTINS.contains(&matched_command) {
                Ok(Some(format!("{} is a shell builtin", matched_command)))
            } else if let Some(path) = find_executable_in_path(&matched_command) {
                Ok(Some(format!("{} is {}", matched_command, path.display())))
            } else {
                Ok(Some(format!("{}: not found", matched_command)))
            }
        }
        // "ulimit" => (),
        // "umask" => (),
        // "unalias" => (),
        // "uname" => (),
        // "uncompress" => (),
        // "unexpand" => (),
        // "unget" => (),
        // "uniq" => (),
        // "unlink" => (),
        // "uucp" => (),
        // "uudecode" => (),
        // "uuencode" => (),
        // "uustat" => (),
        // "uux" => (),
        // "val" => (),
        // "vi" => (),
        // "wait" => (),
        // "wc" => (),
        // "what" => (),
        // "who" => (),
        // "write" => (),
        // "xargs" => (),
        // "xgettext" => (),
        // "yacc" => (),
        // "zcat" => (),
        _ => Ok(None),
    }
}

// should possibly be 156 with exit
// static BUILTINS: [&str; 155] = [
pub static BUILTINS: [&str; 6] = [
    // "admin",
    // "alias",
    // "ar",
    // "asa",
    // "at",
    // "awk",
    // "basename",
    // "batch",
    // "bc",
    // "bg",
    // "cal",
    // "cat", // ALERT THIS IS NOT RIGHT ALERT
    // "cc",
    "cd",
    // "cflow",
    // "chgrp",
    // "chmod",
    // "chown",
    // "cksum",
    // "cmp",
    // "comm",
    // "command",
    // "compress",
    // "cp",
    // "cron",
    // "csplit",
    // "ctags",
    // "cut",
    // "cxref",
    // "date",
    // "dd",
    // "delta",
    // "df",
    // "diff",
    // "dirname",
    // "du",
    "echo", // "ed",
    // "env",
    // "ex",
    "exit",
    // "expand",
    // "expr",
    // "false",
    // "fc",
    // "fg",
    // "file",
    // "find",
    // "fold",
    // "fuser",
    // "gencat",
    // "get",
    // "getconf",
    // "getopts",
    // "gettext",
    // "grep",
    // "hash",
    // "head",
    // "iconv",
    // "id",
    // "ipcrm",
    // "ipcs",
    // "jobs",
    // "join",
    // "kill",
    // "lex",
    // "link",
    // "ln",
    // "locale",
    // "localedef",
    // "logger",
    // "logname",
    // "lp",
    "ls",
    // "m4",
    // "mailx",
    // "make",
    // "man",
    // "mesg",
    // "mkdir",
    // "mkfifo",
    // "more",
    // "msgfmt",
    // "mv",
    // "newgrp",
    // "ngettext",
    // "nice",
    // "nl",
    // "nm",
    // "nohup",
    // "od",
    // "paste",
    // "patch",
    // "pathchk",
    // "pax",
    // "pr",
    // "printf",
    // "prs",
    // "ps",
    "pwd",
    // "read",
    // "readlink",
    // "realpath",
    // "renice",
    // "rm",
    // "rmdel",
    // "rmdir",
    // "sact",
    // "sccs",
    // "sed",
    // "sh",
    // "sleep",
    // "sort",
    // "split",
    // "strings",
    // "strip",
    // "stty",
    // "tabs",
    // "tail",
    // "talk",
    // "tee",
    // "test",
    // "time",
    // "timeout",
    // "touch",
    // "tput",
    // "tr",
    // "true",
    // "tsort",
    // "tty",
    "type",
    // "ulimit",
    // "umask",
    // "unalias",
    // "uname",
    // "uncompress",
    // "unexpand",
    // "unget",
    // "uniq",
    // "unlink",
    // "uucp",
    // "uudecode",
    // "uuencode",
    // "uustat",
    // "uux",
    // "val",
    // "vi",
    // "wait",
    // "wc",
    // "what",
    // "who",
    // "write",
    // "xargs",
    // "xgettext",
    // "yacc",
    // "zcat",
];

// pub fn get_pwd() -> Result<PathBuf, VarError> {
//     let path = env::current_dir();
// println!("{}", path.display());
// match path {
//     Ok(v) => println!("{}", v.display()),
//     Err(e) => println!("{e:?}"),
// }
